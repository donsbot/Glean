"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9403],{3905:function(e,n,r){r.r(n),r.d(n,{MDXContext:function(){return d},MDXProvider:function(){return p},mdx:function(){return x},useMDXComponents:function(){return s},withMDXComponents:function(){return u}});var t=r(67294);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function l(){return l=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var t in r)Object.prototype.hasOwnProperty.call(r,t)&&(e[t]=r[t])}return e},l.apply(this,arguments)}function a(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function o(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?a(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function c(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},l=Object.keys(e);for(t=0;t<l.length;t++)r=l[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)r=l[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var d=t.createContext({}),u=function(e){return function(n){var r=s(n.components);return t.createElement(e,l({},n,{components:r}))}},s=function(e){var n=t.useContext(d),r=n;return e&&(r="function"==typeof e?e(n):o(o({},n),e)),r},p=function(e){var n=s(e.components);return t.createElement(d.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,l=e.originalType,a=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),u=s(r),p=i,h=u["".concat(a,".").concat(p)]||u[p]||m[p]||l;return r?t.createElement(h,o(o({ref:n},d),{},{components:r})):t.createElement(h,o({ref:n},d))}));function x(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=r.length,a=new Array(l);a[0]=h;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:i,a[1]=o;for(var d=2;d<l;d++)a[d]=r[d];return t.createElement.apply(null,a)}return t.createElement.apply(null,r)}h.displayName="MDXCreateElement"},12038:function(e,n,r){r.d(n,{EO:function(){return o},O1:function(){return a},Rr:function(){return c}});var t,i=r(67294),l=r(44256);function a(e){return i.createElement("a",{href:t+e.file},e.file)}function o(e){return i.createElement("a",{href:t+e.file},e.children)}t=(0,l.isInternal)()?"https://www.internalfb.com/code/fbsource/fbcode/":"https://github.com/facebookincubator/Glean/tree/master/";var c=function(e){e.children;var n=e.internal,r=e.external;return(0,l.fbContent)({internal:i.createElement("code",null,n),external:i.createElement("code",null,r)})}},80394:function(e,n,r){r.r(n),r.d(n,{contentTitle:function(){return d},default:function(){return m},frontMatter:function(){return c},metadata:function(){return u},toc:function(){return s}});var t=r(87462),i=r(63366),l=(r(67294),r(3905)),a=(r(44256),r(12038)),o=["components"],c={id:"cxx",title:"C++ and C",sidebar_label:"C++ and C"},d=void 0,u={unversionedId:"indexer/cxx",id:"indexer/cxx",isDocsHomePage:!1,title:"C++ and C",description:'The C++ indexer ("the clang indexer") is a wrapper over',source:"@site/docs/indexer/cxx.md",sourceDirName:"indexer",slug:"/indexer/cxx",permalink:"/docs/indexer/cxx",editUrl:"https://github.com/facebookincubator/Glean/tree/main/glean/website/docs/indexer/cxx.md",tags:[],version:"current",frontMatter:{id:"cxx",title:"C++ and C",sidebar_label:"C++ and C"},sidebar:"someSidebar",previous:{title:"Introduction",permalink:"/docs/indexer/intro"},next:{title:"JavaScript (Flow)",permalink:"/docs/indexer/flow"}},s=[{value:"To build the indexer:",id:"to-build-the-indexer",children:[],level:2},{value:"Run the indexer",id:"run-the-indexer",children:[],level:2},{value:"In the shell",id:"in-the-shell",children:[],level:2},{value:"Schema",id:"schema",children:[],level:2}],p={toc:s};function m(e){var n=e.components,r=(0,i.Z)(e,o);return(0,l.mdx)("wrapper",(0,t.Z)({},p,r,{components:n,mdxType:"MDXLayout"}),(0,l.mdx)("p",null,'The C++ indexer ("the clang indexer") is a wrapper over\n',(0,l.mdx)("a",{parentName:"p",href:"https://clang.llvm.org/"},"clang"),". The clang indexer is a drop in replacement\nfor the C++ compiler that emits Glean facts instead of code. The wrapper is\nlinked against libclang and libllvm."),(0,l.mdx)("p",null,"Glean supports simple cmake builds out of the box. For other build systems\nyou'll need to run clang-index manually on compilation targets. The indexer has\nbeen designed to scale up to very large repos, indexing compilation units in\nparallel across multiple machines, however support for parallel indexing isn't\nin the open source release. The indexer performance on C++ code is similar to\nrunning the clang frontend."),(0,l.mdx)("p",null,"To build the indexer, you will need clang, libclang, llvm. See the\n",(0,l.mdx)("a",{parentName:"p",href:"https://github.com/facebookincubator/Glean/blob/main/.github/workflows/ci.yml"},"github CI\nworkflow"),"\nfor the specific dependencies we test with. We tend to test on one or two\nspecific versions of clang and llvm (currently clang 11 and 12), but other\nversions may work."),(0,l.mdx)("p",null,"The indexer consists of two parts:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"clang-index")),(0,l.mdx)("p",null,"which compiles the C++ source and emits binary thrift data to write to Glean."),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"clang-derive")),(0,l.mdx)("p",null,"which computes derived facts on the result (e.g. find-references tables)."),(0,l.mdx)("h2",{id:"to-build-the-indexer"},"To build the indexer:"),(0,l.mdx)("blockquote",null,(0,l.mdx)("p",{parentName:"blockquote"},"make glean-clang")),(0,l.mdx)("h2",{id:"run-the-indexer"},"Run the indexer"),(0,l.mdx)("p",null,"A simple cmake-based indexer can run via the main ",(0,l.mdx)("inlineCode",{parentName:"p"},"glean")," CLI tool."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"> cabal build exe:glean\n")),(0,l.mdx)("p",null,"And index your c++ repository with:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"glean index cpp-cmake DIR --indexer clang-index --deriver clang-derive --repo name/hash\n")),(0,l.mdx)("p",null,"where"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"DIR")," is the root directory containing the CMake manifest."),(0,l.mdx)("li",{parentName:"ul"},"and indexer and deriver are the paths to the clang-index and clang-derive binaries")),(0,l.mdx)("h2",{id:"in-the-shell"},"In the shell"),(0,l.mdx)("p",null,"C++ source in cmake projects can also be indexed directly from the Glean shell:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},":index cpp-cmake DIR\n")),(0,l.mdx)("p",null,"Note that clang-index and clang-derive should be built and accessible in the\nPATH variable for this to succeed, or in the build tree."),(0,l.mdx)("h2",{id:"schema"},"Schema"),(0,l.mdx)("p",null,"The schema is in ",(0,l.mdx)(a.O1,{file:"glean/schema/source/cxx1.angle",mdxType:"SrcFile"})),(0,l.mdx)("p",null,"The schema is quite rich and captures C++, C, Objective-C and C pre-processor\nsymbols, the semantic structure of C++ symbols, and is precise enough to do\nautomated analysis of C++ code."))}m.isMDXComponent=!0}}]);