"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9403],{3905:function(e,n,t){t.r(n),t.d(n,{MDXContext:function(){return d},MDXProvider:function(){return p},mdx:function(){return x},useMDXComponents:function(){return s},withMDXComponents:function(){return u}});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(){return l=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},l.apply(this,arguments)}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},l=Object.keys(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var d=r.createContext({}),u=function(e){return function(n){var t=s(n.components);return r.createElement(e,l({},n,{components:t}))}},s=function(e){var n=r.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=s(e.components);return r.createElement(d.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,l=e.originalType,a=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),u=s(t),p=i,h=u["".concat(a,".").concat(p)]||u[p]||m[p]||l;return t?r.createElement(h,o(o({ref:n},d),{},{components:t})):r.createElement(h,o({ref:n},d))}));function x(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=t.length,a=new Array(l);a[0]=h;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:i,a[1]=o;for(var d=2;d<l;d++)a[d]=t[d];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},12038:function(e,n,t){t.d(n,{EO:function(){return o},O1:function(){return a},Rr:function(){return c}});var r,i=t(67294),l=t(44256);function a(e){return i.createElement("a",{href:r+e.file},e.file)}function o(e){return i.createElement("a",{href:r+e.file},e.children)}r=(0,l.isInternal)()?"https://www.internalfb.com/code/fbsource/fbcode/":"https://github.com/facebookincubator/Glean/tree/master/";var c=function(e){e.children;var n=e.internal,t=e.external;return(0,l.fbContent)({internal:i.createElement("code",null,n),external:i.createElement("code",null,t)})}},80394:function(e,n,t){t.r(n),t.d(n,{contentTitle:function(){return d},default:function(){return m},frontMatter:function(){return c},metadata:function(){return u},toc:function(){return s}});var r=t(87462),i=t(63366),l=(t(67294),t(3905)),a=(t(44256),t(12038)),o=["components"],c={id:"cxx",title:"C++ and C",sidebar_label:"C++ and C"},d=void 0,u={unversionedId:"indexer/cxx",id:"indexer/cxx",isDocsHomePage:!1,title:"C++ and C",description:'The C++ indexer ("the clang indexer") is a wrapper over',source:"@site/docs/indexer/cxx.md",sourceDirName:"indexer",slug:"/indexer/cxx",permalink:"/docs/indexer/cxx",editUrl:"https://github.com/facebookincubator/Glean/tree/main/glean/website/docs/indexer/cxx.md",tags:[],version:"current",frontMatter:{id:"cxx",title:"C++ and C",sidebar_label:"C++ and C"},sidebar:"someSidebar",previous:{title:"Introduction",permalink:"/docs/indexer/intro"},next:{title:"JavaScript (Flow)",permalink:"/docs/indexer/flow"}},s=[{value:"To build the indexer:",id:"to-build-the-indexer",children:[],level:2},{value:"Run the indexer",id:"run-the-indexer",children:[],level:2},{value:"In the shell",id:"in-the-shell",children:[],level:2},{value:"Schema",id:"schema",children:[],level:2}],p={toc:s};function m(e){var n=e.components,t=(0,i.Z)(e,o);return(0,l.mdx)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,l.mdx)("p",null,'The C++ indexer ("the clang indexer") is a wrapper over\n',(0,l.mdx)("a",{parentName:"p",href:"https://clang.llvm.org/"},"clang"),". The clang indexer is a drop in replacement\nfor the a C++ compiler that emits Glean facts instead of code. The wrapper is\nlinked against libclang and libllvm."),(0,l.mdx)("p",null,"Glean supports simple cmake builds out of the box. For other build systems\nyou'll need to run clang-index manually on compilation targets. The indexer has\nbeen designed to scale up to very large repos, indexing compilation units in\nparallel across multiple machines."),(0,l.mdx)("p",null,"To build the indexer, you will need clang-11, libclang-11, llvm-11. See the\n",(0,l.mdx)("a",{parentName:"p",href:"https://github.com/facebookincubator/Glean/blob/main/.github/workflows/ci.yml"},"github CI\nworkflow"),"\nfor the specific dependencies we test with."),(0,l.mdx)("p",null,"The indexer consists of two parts:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"clang-index")),(0,l.mdx)("p",null,"which compiles the C++ source and emits binary thrift data to write to Glean."),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"clang-derive")),(0,l.mdx)("p",null,"which computes derived facts on the result (e.g. find-references tables)."),(0,l.mdx)("h2",{id:"to-build-the-indexer"},"To build the indexer:"),(0,l.mdx)("blockquote",null,(0,l.mdx)("p",{parentName:"blockquote"},"make glean-clang")),(0,l.mdx)("h2",{id:"run-the-indexer"},"Run the indexer"),(0,l.mdx)("p",null,"The cmake-based indexer can run via the main ",(0,l.mdx)("inlineCode",{parentName:"p"},"glean")," CLI tool."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"> cabal build exe:glean\n")),(0,l.mdx)("p",null,"And index your c++ repository with:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"glean index cpp DIR --indexer clang-index --deriver clang-derive --repo name/hash\n")),(0,l.mdx)("p",null,"where"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"DIR")," is the root directory containing the CMake manifest."),(0,l.mdx)("li",{parentName:"ul"},"and indexer and deriver are the paths to the clang-index and clang-derive binaries")),(0,l.mdx)("h2",{id:"in-the-shell"},"In the shell"),(0,l.mdx)("p",null,"C++ source in cmake projects can also be indexed directly from the Glean shell:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},":index cpp DIR\n")),(0,l.mdx)("p",null,"Note that clang-index and clang-derive should be built and accessible in the\nPATH variable for this to succeed, or in the build tree."),(0,l.mdx)("h2",{id:"schema"},"Schema"),(0,l.mdx)("p",null,"The schema is in ",(0,l.mdx)(a.O1,{file:"glean/schema/source/cxx1.angle",mdxType:"SrcFile"})),(0,l.mdx)("p",null,"The schema is quite rich and captures C++, C, Objective-C and C pre-processor\nsymbols, the semantic structure of C++ symbols, and is precise enough to do\nautomated analysis of C++ code."))}m.isMDXComponent=!0}}]);